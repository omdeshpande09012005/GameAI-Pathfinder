// src/main.cpp
#include <iostream>
#include <string>
#include <chrono>
#include <random>
#include <vector>
#include "grid.h"
#include "astar.h"
#include "qlearning.h"

// Simple CLI parser (minimal)
struct CliOptions {
    std::string algo = "astar";          // "astar" or "qlearn"
    std::string map_path = "maps/demo_map.txt";
    int train_episodes = 1000;          // only used for qlearn
    int seed = 42;
    int runs = 1;                        // evaluation runs after training
    bool help = false;
};

void print_usage(const char* prog) {
    std::cout <<
    "Usage: " << prog << " [--algo astar|qlearn] [--map <path>] [--train-episodes N] [--seed N] [--runs N]\n\n"
    "Options:\n"
    "  --algo astar|qlearn       Select algorithm (default: astar)\n"
    "  --map <path>              Path to map file (default: maps/demo_map.txt)\n"
    "  --train-episodes N        Training episodes for Q-Learning (default: 1000)\n"
    "  --seed N                  RNG seed (default: 42)\n    --runs N                 Number of evaluation runs after training (default: 1)\n"
    "  --help                    Show this help message\n\n"
    "Examples:\n"
    "  " << prog << " --algo astar --map maps/demo_map.txt\n"
    "  " << prog << " --algo qlearn --train-episodes 2000 --map maps/demo_map.txt --runs 3\n";
}

CliOptions parse_cli(int argc, char** argv) {
    CliOptions opt;
    for (int i = 1; i < argc; ++i) {
        std::string a = argv[i];
        if (a == "--help" || a == "-h") {
            opt.help = true;
            return opt;
        } else if (a == "--algo" && i+1 < argc) {
            opt.algo = argv[++i];
        } else if (a == "--map" && i+1 < argc) {
            opt.map_path = argv[++i];
        } else if (a == "--train-episodes" && i+1 < argc) {
            opt.train_episodes = std::stoi(argv[++i]);
        } else if (a == "--seed" && i+1 < argc) {
            opt.seed = std::stoi(argv[++i]);
        } else if (a == "--runs" && i+1 < argc) {
            opt.runs = std::stoi(argv[++i]);
        } else {
            std::cerr << "Unknown or malformed option: " << a << "\n";
            opt.help = true;
            return opt;
        }
    }
    return opt;
}

int main(int argc, char** argv) {
    CliOptions opt = parse_cli(argc, argv);
    if (opt.help) { print_usage(argv[0]); return 0; }

    // seed rngs
    std::srand(opt.seed);
    std::mt19937 rng(opt.seed);

    Grid grid;
    if (!grid.loadFromFile(opt.map_path)) {
        std::cerr << "Failed to load map: " << opt.map_path << "\n";
        return 1;
    }

    int sx = grid.startX(), sy = grid.startY();
    int gx = grid.goalX(), gy = grid.goalY();

    if (opt.algo == "astar") {
        AStarAgent astar;
        auto t0 = std::chrono::high_resolution_clock::now();
        Result r = astar.run(grid, sx, sy, gx, gy);
        auto t1 = std::chrono::high_resolution_clock::now();
        double ms = std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count() / 1000.0;
        // Print in CSV-friendly format for scripts
        std::cout << "A*: success=" << (r.success ? 1 : 0)
                  << " steps=" << r.steps
                  << " path_len=" << r.path_length
                  << " time_ms=" << ms << std::endl;
        return 0;
    } else if (opt.algo == "qlearn") {
        QLearningAgent ql;
        ql = QLearningAgent(); // default init (you can adapt with alpha,gamma,eps if you want)
        // set RNG seed inside the agent if needed (not shown here)
        std::cout << "[INFO] Training Q-Learning for " << opt.train_episodes << " episodes (seed=" << opt.seed << ")\n";
        ql.train(grid, gx, gy, opt.train_episodes);

        // evaluation runs
        for (int run = 1; run <= opt.runs; ++run) {
            auto t0 = std::chrono::high_resolution_clock::now();
            Result r = ql.run(grid, sx, sy, gx, gy);
            auto t1 = std::chrono::high_resolution_clock::now();
            double ms = std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count() / 1000.0;
            // Q-Learn prints (no time by default previously) â€” include time_ms=ms for parity
            std::cout << "Q-Learn: success=" << (r.success ? 1 : 0)
                      << " steps=" << r.steps
                      << " path_len=" << r.path_length
                      << " time_ms=" << ms << std::endl;
        }
        return 0;
    } else {
        std::cerr << "Unknown algorithm: " << opt.algo << "\n";
        print_usage(argv[0]);
        return 1;
    }
}
